}
acc
}
display_text = function(text, linewidth, pswd =  "X") {
txt = splt(text %>% str_replace_all(pswd, ""), linewidth) %>% str_replace_all("1", green("1"))
cat(paste0(txt, collapse = "\n"))
}
client <- function(){
text = readRDS("message.RDS")
quit=FALSE
while(!quit){
readline("Connecting to server: first run the server and then press enter to continue...")
con <- socketConnection(host="192.168.2.3", port = 7337, blocking=TRUE,
server=FALSE, open="r+", timeout=15)
writeLines("REQUEST_CONNECT", con)
data = readLines(con, 1)
if(data=="CONNECT_SUCCESS") {
while(!quit) {
cat("Waiting for password...\n")
pswd = readLines(con, 1)
if (length(pswd)>0) {
if(pswd=="QUIT") {
quit=TRUE
break
} else {
display_text(text, linewidth, pswd)
cat("\n")
}
}
}
}
close(con)
}
}
client()
client()
client <- function(){
text = readRDS("message.RDS")
quit<<-FALSE
while(!quit){
readline("Connecting to server: first run the server and then press enter to continue...")
con <- socketConnection(host="192.168.2.3", port = 7337, blocking=TRUE,
server=FALSE, open="r+", timeout=15)
writeLines("REQUEST_CONNECT", con)
data = readLines(con, 1)
if(data=="CONNECT_SUCCESS") {
while(!quit) {
cat("Waiting for password...\n")
pswd = readLines(con, 1)
if (length(pswd)>0) {
if(pswd=="QUIT") {
quit<<-TRUE
close(con)
break
} else {
display_text(text, linewidth, pswd)
cat("\n")
}
}
}
}
close(con)
}
}
client()
client <- function(){
text = readRDS("message.RDS")
qt=FALSE
while(!qt){
readline("Connecting to server: first run the server and then press enter to continue...")
con <- socketConnection(host="192.168.2.3", port = 7337, blocking=TRUE,
server=FALSE, open="r+", timeout=15)
writeLines("REQUEST_CONNECT", con)
data = readLines(con, 1)
if(data=="CONNECT_SUCCESS") {
while(!qt) {
cat("Waiting for password...\n")
pswd = readLines(con, 1)
if (length(pswd)>0) {
if(pswd=="QUIT") {
qt=TRUE
close(con)
break
} else {
display_text(text, linewidth, pswd)
cat("\n")
}
}
}
}
close(con)
}
}
client()
client <- function(){
text = readRDS("message.RDS")
qt=FALSE
while(!qt){
readline("Connecting to server: first run the server and then press enter to continue...")
con <- socketConnection(host="192.168.2.3", port = 7337, blocking=TRUE,
server=FALSE, open="r+", timeout=15)
writeLines("REQUEST_CONNECT", con)
data = readLines(con, 1)
if(data=="CONNECT_SUCCESS") {
while(!qt) {
print(qt)
cat("Waiting for password...\n")
pswd = readLines(con, 1)
if (length(pswd)>0) {
if(pswd=="QUIT") {
qt=TRUE
close(con)
break
} else {
display_text(text, linewidth, pswd)
cat("\n")
}
}
}
}
close(con)
}
}
client()
client <- function(){
text = readRDS("message.RDS")
qt<<-FALSE
while(!qt){
readline("Connecting to server: first run the server and then press enter to continue...")
con <- socketConnection(host="192.168.2.3", port = 7337, blocking=TRUE,
server=FALSE, open="r+", timeout=15)
writeLines("REQUEST_CONNECT", con)
data = readLines(con, 1)
if(data=="CONNECT_SUCCESS") {
while(!qt) {
print(qt)
cat("Waiting for password...\n")
pswd = readLines(con, 1)
if (length(pswd)>0) {
if(pswd=="QUIT") {
qt<<-TRUE
close(con)
break
} else {
display_text(text, linewidth, pswd)
cat("\n")
}
}
}
}
close(con)
}
}
client()
qt
client <- function(){
text = readRDS("message.RDS")
abort_client<<-FALSE
while(!abort_client){
readline("Connecting to server: first run the server and then press enter to continue...")
con <- socketConnection(host="192.168.2.3", port = 7337, blocking=TRUE,
server=FALSE, open="r+", timeout=15)
writeLines("REQUEST_CONNECT", con)
data = readLines(con, 1)
if(data=="CONNECT_SUCCESS") {
while(!abort_client) {
print(abort_client)
cat("Waiting for password...\n")
pswd = readLines(con, 1)
if (length(pswd)>0) {
if(pswd=="QUIT") {
abort_client<<-TRUE
close(con)
break
} else {
display_text(text, linewidth, pswd)
cat("\n")
}
}
}
}
close(con)
}
}
client()
client <- function(){
text = readRDS("message.RDS")
abort_client<<-FALSE
while(!abort_client){
readline("Connecting to server: first run the server and then press enter to continue...")
con <- socketConnection(host="192.168.2.3", port = 7337, blocking=TRUE,
server=FALSE, open="r+", timeout=15)
writeLines("REQUEST_CONNECT", con)
data = readLines(con, 1)
if(data=="CONNECT_SUCCESS") {
while(!abort_client) {
print(abort_client)
cat("Waiting for password...\n")
pswd = readLines(con, 1)
browser()
print(pswd)
if (length(pswd)>0) {
if(pswd=="QUIT") {
abort_client<<-TRUE
close(con)
break
} else {
display_text(text, linewidth, pswd)
cat("\n")
}
}
}
}
close(con)
}
}
client()
print(pswd)
pswd = readLines(con, 1)
pswd = readLines(con, 1)
client <- function(){
text = readRDS("message.RDS")
abort_client<<-FALSE
while(!abort_client){
readline("Connecting to server: first run the server and then press enter to continue...")
con <- socketConnection(host="192.168.2.3", port = 7337, blocking=TRUE,
server=FALSE, open="r+", timeout=15)
writeLines("REQUEST_CONNECT", con)
data = readLines(con, 1)
if(data=="CONNECT_SUCCESS") {
while(!abort_client) {
print(abort_client)
cat("Waiting for password...\n")
pswd = readLines(con, 1)
if (length(pswd)>0) {
if(pswd=="QUIT") {
abort_client<<-TRUE
close(con)
break
} else {
display_text(text, linewidth, pswd)
cat("\n")
}
}
}
}
close(con)
}
}
client
client()
client <- function(){
text = readRDS("message.RDS")
while(TRUE){
readline("Connecting to server: first run the server and then press enter to continue...")
con <- socketConnection(host="192.168.2.3", port = 7337, blocking=TRUE,
server=FALSE, open="r+", timeout=15)
writeLines("REQUEST_CONNECT", con)
data = readLines(con, 1)
if(data=="CONNECT_SUCCESS") {
while(TRUE) {
cat("Waiting for password...\n")
pswd = readLines(con, 1)
if (length(pswd)>0) {
if(pswd=="QUIT") {
close(con)
return()
} else {
display_text(text, linewidth, pswd)
cat("\n")
}
}
}
}
close(con)
}
}
client()
library(hgutils)
startup()
library(crayon)
library(BMS)
library(stringr)
#draait op PC
server <- function(){
while(TRUE){
cat("Waiting for client to connect...\n")
con <- socketConnection(host="192.168.2.3", port = 7337, blocking=TRUE,
server=TRUE, open="r+", timeout = 3600)
data <- readLines(con, 1)
if(data=="REQUEST_CONNECT") {
cat(green("Client connected"), "\n")
writeLines("CONNECT_SUCCESS", con)
while(TRUE) {
pswd = readline("Enter password (QUIT to close connection): ")
if(pswd=="")
pswd="X"
writeLines(trimws(pswd), con)
if(trimws(pswd) == "QUIT")
break;
cat(green("Encrypted message sent.\n"))
}
}
close(con)
}
}
source("image_processing.R")
#draait op RPI
settings <<- c(bits="128", TZ="GMT+1", colorcoding="FALSE", encryption="TRUE")
text = "The hexadecimal numeral system, also known as just hex, is a numeral system made up of 16 symbols (base 16).
The standard numeral system is called decimal (base 10) and uses ten symbols: 0,1,2,3,4,5,6,7,8,9. Hexadecimal uses the decimal numbers and includes six extra symbols.
There are no symbols that mean ten, or eleven etc. so these symbols are letters taken " %+% red("f") %+% "rom the English alphabet: A, B, C, D, E and F.
Hexadecimal A = decimal 10, and hexadecimal F = decimal 15.
Humans mostly use the decimal system. This is probably because humans have ten fingers (ten digits).
Computers however, only have on and off, called a binary digit (or bit, for short). " %+% red("A") %+% " binary number is just a string of zeros and ones: 11011011, for example.
For convenience, engineers working with computers tend to group bits together. In earlier days, such as the 1960's,
they would group 3 bits at a time (much like large decimal numbers are grouped in threes, like the number 123,456,789).
Three bits, each being on or off, can represent the eight numbers from 0 to 7: 000 = 0; 001 = 1; 010 = 2; 011 = 3; 100 = 4; 101 = 5; 110 = 6 and 111 = 7.
This is called o"%+% red("c") %+% "tal. As computers got bigger, it was more convenient to group bits by four instead of three.
This doubles the numbers that the symbol would represent; it can h"%+% red("a") %+% "ve 16 values instead of eight.
Hex = 6 and Decimal = 10, so it is called hexa"%+% red("d") %+% "ecimal.
Four bits is called a nibble (sometimes spelled nybble). A nibble is one hexadecimal digit, and is written using a symbol 0-9 or A-F.
Two nibbles is a byte (8 bits). Most computer operations use the byte, or a multiple of the byte (16 bits, 24, 32, 64, etc.).
Hexadecimal makes it easier to write these large binary numbers. To avoid confusion with decimal, octal or other numbering systems,
hexadecimal numbers are sometim"%+% red("e") %+% "s written with a \"h\" after the number. For example, 63h means 63 hexadecimal.
Software developers quite often use 0x before the number (0x63)."
#cat(text)
#cat(strip_style(text))
clc = function() {cat("\014");  system("clear")}
update_settings = function(settings) {
while (TRUE) {
clc()
cat(cyan("Current settings: "),"\n")
cat(paste0(names(settings), ": ", green(settings),collapse = "\n"), "\n\n\n")
val = menu(names(settings), title = "Change value (0 to exit)")
if(val != 0) {
new_val = readline(paste0("New value for [", names(settings)[val],"]: "))
settings[val] = new_val
} else {
break
}
}
settings
}
translate = function() {
clc()
input = toupper(readline("Enter phrase: "))
if (str_detect(input, "^[0-9A-F]+$")) {
output = paste0(hex2bin(input), collapse = "")
output = paste0(strsplit(output,"(?<=\\G.{4})", perl = TRUE)[[1]], collapse = " ")
cat("Output:", green(output))
} else {
cat(red("ERROR: input must be hexadecimal."))
}
cat("\n\n")
readline("Press enter to continue...")
}
display_enc = function(settings) {
clc()
if("colorcoding" %in% names(settings) && settings["colorcoding"] == "TRUE") {
cat(text)
} else {
cat(strip_style(text))
}
cat("\n\n")
readline("Press enter to continue...")
}
main_menu = function() {
while (TRUE) {
clc()
options = c("Encyclopaedia", "Translate", "Settings")
val = menu(options, title="Choose option")
if(val == 1) {
display_enc(settings)
} else if (val == 2) {
translate()
} else if (val == 3) {
settings <<- update_settings(settings)
} else if (val == 4) {
client()
}
}
}
main_menu()
server <- function(){
while(TRUE){
cat("Waiting for client to connect...\n")
con <- socketConnection(host="192.168.2.3", port = 7337, blocking=TRUE,
server=TRUE, open="r+", timeout = 3600)
data <- readLines(con, 1)
if(data=="REQUEST_CONNECT") {
cat(green("Client connected"), "\n")
writeLines("CONNECT_SUCCESS", con)
while(TRUE) {
pswd = readline("Enter password (QUIT to close connection): ")
if(pswd=="")
pswd="X"
writeLines(trimws(pswd), con)
if(trimws(pswd) == "QUIT")
break;
cat(green("Encrypted message sent.\n"))
}
}
close(con)
}
}
library(hgutils)
library(crayon)
library(BMS)
library(stringr)
server <- function(){
while(TRUE){
cat("Waiting for client to connect...\n")
con <- socketConnection(host="192.168.2.3", port = 7337, blocking=TRUE,
server=TRUE, open="r+", timeout = 3600)
data <- readLines(con, 1)
if(data=="REQUEST_CONNECT") {
cat(green("Client connected"), "\n")
writeLines("CONNECT_SUCCESS", con)
while(TRUE) {
pswd = readline("Enter password (QUIT to close connection): ")
if(pswd=="")
pswd="X"
writeLines(trimws(pswd), con)
if(trimws(pswd) == "QUIT")
break;
cat(green("Encrypted message sent.\n"))
}
}
close(con)
}
}
server()
library(hgutils)
library("BMS")
library("stringr")
library("crayon")
generate_text = function(key, linewidth) {
ok = FALSE
while(!ok) {
img = load.image("mssg.png")
width = width(img); height=height(img)
img %<>% resize(size_x=linewidth, size_y=round(linewidth/width*height), size_c = 1) %>% {.>0.5} %>% as.matrix
img = apply(t(img), c(1,2), function(x) ifelse(x,ifelse(runif(1)>0.9,"1","0"),"1"))
text = img %>% apply(1, function(x) paste0(x,collapse = ""))
ok = !any(sapply(text, function(x) str_detect(x,key)))
}
text %<>% sapply(function(x) {r = floor(runif(1,0,nchar(x))); paste0(str_sub(x,1,r), key, str_sub(x,r+1,nchar(x)))})
text %<>% paste0(collapse = "")
}
splt = function(str, length = 180) {
acc = c()
while(nchar(str) > length) {
acc = c(acc, substr(str, 1, length))
str = substr(str,length+1,nchar(str))
}
acc
}
display_text = function(text, linewidth, pswd =  "X") {
txt = splt(text %>% str_replace_all(pswd, ""), linewidth) %>% str_replace_all("1", green("1"))
cat(paste0(txt, collapse = "\n"))
}
library(hgutils)
startup()
library(imager)
key = "FACADE" %>% hex2bin %>% paste0(collapse = "")
generate_text = function(key, linewidth) {
ok = FALSE
while(!ok) {
img = load.image("mssg.png")
width = width(img); height=height(img)
img %<>% resize(size_x=linewidth, size_y=round(linewidth/width*height), size_c = 1) %>% {.>0.5} %>% as.matrix
img = apply(t(img), c(1,2), function(x) ifelse(x,ifelse(runif(1)>0.9,"1","0"),"1"))
text = img %>% apply(1, function(x) paste0(x,collapse = ""))
ok = !any(sapply(text, function(x) str_detect(x,key)))
}
text %<>% sapply(function(x) {r = floor(runif(1,0,nchar(x))); paste0(str_sub(x,1,r), key, str_sub(x,r+1,nchar(x)))})
text %<>% paste0(collapse = "")
}
source("image_util.R")
text = generate_text(key, linewidth)
saveRDS(text, "message.RDS")
source("image_util.R")
library(hgutils)
library(crayon)
library(BMS)
library(stringr)
server <- function(){
while(TRUE){
cat("Waiting for client to connect @ 192.168.2.3:7337...\n")
con <- socketConnection(host="192.168.2.3", port = 7337, blocking=TRUE,
server=TRUE, open="r+", timeout = 3600)
data <- readLines(con, 1)
if(data=="REQUEST_CONNECT") {
cat(green("Client connected"), "\n")
writeLines("CONNECT_SUCCESS", con)
while(TRUE) {
pswd = readline("Enter password (QUIT to close connection): ")
if(pswd=="")
pswd="X"
writeLines(trimws(pswd), con)
if(trimws(pswd) == "QUIT")
break;
cat(green("Encrypted message sent.\n"))
}
}
close(con)
}
}
server()
key
server()
